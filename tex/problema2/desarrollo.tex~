Lo que hayamos (y demostramos luego en este informe) es que el orden óptimo es de menor a mayor según el coeficiente $\frac{Tiempo_i}{Perdida_i}$. El orden es el siguiente:

$(\forall i \in [1..\#{piezas})) \frac{Tiempo_i}{Perdida_i} < \frac{Tiempo_{i+1}}{Perdida_{i+1}}$

Lo que nuestro algoritmo hace es leer la entrada que nos pasan, y formar un vector con todas las piezas, éstas tienen un atributo para identificarlas, otro que indica la cantidad de días que se tarda en fabricarla, y uno que indica la pérdida por día.

Una vez generado el vector con todas las piezas, lo ordenamos de menor a mayor según el coeficiente antes dicho, para eso usamos el algoritmo ``Sort'' de la librería \emph{<algorithm>} de C++.

Luego calculamos la perdida que ocasiona armar las piezas en el orden que nosotros propusimos y para terminar