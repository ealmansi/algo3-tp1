Al igual que en el problema anterior, lo primero que hicimos fue verificar empíricamente la cota de complejidad temporal teórica que demostramos para el algoritmo completo. 
A continuación tenemos cuatro figuras que nos permiten ver que efectivamente nuestro algoritmo es $O(n log(n))$

figura1 normal mil
figura2 normal / log n (o sobre n * log n)
figura3 normal 10 mil
figura4 normal 10 mil / log n (sobre n * log n)

Como se puede observar en las figuras 2 y 4, una vez que dividimos por $log n$, los tiempos de las mediciones que tomamos forman una recta en función de $n$. Esto significa que la complejidad del algoritmo en su totalidad es de $O(n log(n))$.

Al igual que en el problema anterior se observa un pico en los $n$ bajos. Esto al igual que antes se debe al comportamiento del algoritmo de ordenamiento utilizado.

Como la complejidad temporal de la solución también es dominada por la etapa de ordenamiento y, como dijimos antes, el algoritmo que usamos para resolver dicha etapa pertenece a librerías estándares. Por lo tanto para continuar la experimentación también realizamos pruebas sobre instancias donde la entrada se encuentra ordenada, eliminando la etapa de ordenamiento. Esto permitió constatar que el resto del algoritmo tiene efectivamente un costo a lo sumo lineal, y verificar la preponderancia del ordenamiento en la complejidad final de nuestro algoritmo.

En las figuras siguientes podemos observar que, eliminando la etapa de ordenamiento, nuestro algoritmo es $O(n)$.

figura5 MIL
figura 6 10 mil

cada figura tiene width = anchoPagina / 2