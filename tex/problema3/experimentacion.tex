\emph{Nota:} Como vamos a hablar mucho de las distintas podas vamos a denominarlas de la siguiente manera:
\begin{itemize}
\item Poda 1: Si aunque ponga piezas en los casilleros que me queda revisar, no llego a alcanzar la cantidad de piezas de la solución óptima encontrada a ese momento, corto.
\item Poda 2: Similar a la poda 1, pero además revisa hasta $m$ casillas para adelante teniendo en cuenta las restricciones ya existentes en el tablero.
\end{itemize}

En este ejercicio, vamos a enfocar la experimentación orientándolo a la comparación entre las distintas podas, así como también comparar las mismas contra no usar ninguna poda. Cabe aclarar que no usar ninguna poda tiene un método de corte \emph{naïf}: cortar si logré llenar el tablero.

En el siguiente gráfico se puede observar que utilizar podas mejora drásticamente el tiempo de ejecución.

Figura 1: Tablero 2*2 (sin poda, con poda, etc)

A su vez, pudimos observar que sin utilizar podas la complejidad es de $O((n*m)^{n*m})$ ya que revisa todos los tableros posibles, y una vez revisados todos termina. Esto implica que ya para tableros de 3*3 es un número grande de tableros posibles, y para tableros aún más grandes el algoritmo tarda una cantidad incomparable de tiempo con respecto a las podas.

Por esta razón, los siguientes casos sólo van a ser comparados utilizando podas.

Figuras mostrando distintos tableros (3*3, 4*4, 4*1, 4*2, 5*1, etc. No tienen por que ser cuadrados) y usando distintas podas, mostrando como mejora y eso.

En el gráfico X, se puede observar claramente que la poda 2 logra podar mas casos, pero no logra compensar lo suficiente el costo adicional de $O(m)$ para lograr que sea considerablemente mejor que la segunda poda. Dicha poda podría servir en otro problema en el que cual cada llamada recursiva tenga un mayor costo.

///Estaria bueno ver si mejora en casos mas "flacos" (mas filas que columnas) o "gordos" (viceversa)

Por otro lado, la poda 1 también tiene otros beneficios. Es considerablemente más fácil de implementar que la poda 2. A su vez, la poda 1 no depende de la cantidad de colores existentes, mientras que la poda 2 sí lo hace. La poda 2 crea un $vector<int>$ donde la cantidad de posiciones se corresponde con la cantidad de colores existentes. Si bien no es un problema muy grave, puede ocurrir que sí lo sea si tenemos una computadora con memoria acotada y tenemos un caso donde la cantidad de colores es muy alta, como por ejemplo un millón de colores.