\emph{Nota:} Como vamos a hablar mucho de las distintas podas vamos a denominarlas de la siguiente manera:
\begin{itemize}
\item Primer poda: Terminar cuando lleno el tablero.
\item Segunda poda: Si aunque ponga piezas en los casilleros que me queda revisar, no llego a alcanzar la cantidad de piezas de la solución óptima encontrada a ese momento, corto.
\item Tercer poda: Similar a la segunda poda, pero además revisa hasta $m$ casillas para adelante teniendo en cuenta las restricciones ya existentes en el tablero.
\end{itemize}

En este ejercicio, vamos a enfocar la experimentación orientándolo a la comparación entre las distintas podas, así como también comparar las mismas contra no usar ninguna poda.

En el siguiente gráfico se puede observar que utilizar podas mejora drásticamente el tiempo de ejecución.

Figura 1: Tablero 2*2 (sin poda, con poda, etc)

A su vez, pudimos observar que sin utilizar podas la complejidad es de $O((n*m)^{n*m})$ ya que revisa todos los tableros posibles, y una vez revisados todos termina. Esto implica que ya para tableros de 3*3 es un número grande de tableros posibles, y para tableros aún más grandes el algoritmo tarda una cantidad incomparable de tiempo con respecto a las podas.

Por esta razón, los siguientes casos sólo van a ser comparados utilizando podas.

Figuras mostrando distintos tableros (3*3, 4*4, 4*1, 4*2, 5*1, etc. No tienen por que ser cuadrados) y usando distintas podas, mostrando como mejora y eso.

En el gráfico X, se puede observar claramente que la tercer poda logra podar mas casos, pero no logra compensar lo suficiente el costo adicional de $O(m)$ para lograr que sea considerablemente mejor que la segunda poda. Dicha poda podría servir en otro problema en el que cual cada llamada recursiva tenga un mayor costo.

///Estaria bueno ver si mejora en casos mas "flacos" (mas filas que columnas) o "gordos" (viceversa)