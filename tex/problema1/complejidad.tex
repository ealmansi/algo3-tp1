Antes de empezar la demostración vamos a aclarar algo que vale tanto para el problema 1 como el 2:

En los algoritmos 1 y 2 usamos el algoritmo sort de la stl. Para lograr calcular las complejidades de ambos, necesitamos saber la complejidad de dicho algoritmo. Buscando en la pagina de http://www.cplusplus.com/reference/algorithm/sort/, encontramos que su complejidad es O(n.log n ) comparaciones. Como con sólo esta informacion no podíamos asegurar que tenga complejidad O(n.log n) operaciones, buscamos que hace el algoritmo sort. Encontramos que para casos chicos hace InsertionSort (ERA ESTE?), y en casos mas grandes IntroSort. IntroSort intenta ordenar usando QuickSort, si no lo resuelve en n.log n pasos, usa HeapSort para garantizar O(n.log n) comparaciones. Viendo el código del algortimo llegamos a que ademas de hacer O(n.log n) comparaciones tambien hace a lo sumo O(n.log n) swaps.

Como en ambos casos donde usamos el algoritmo sort de la stl, nuestros parametros son vector<int> sabemos que la comparaciones y swaps son O(1). Por lo cual podemos garantizar que sort tiene una complejidad O(n log n) operaciones.

Dicho esto pasamos a demostrar que la complejidad del algoritmo utilizado para resolver el problema 1 es O(n log n).

%ACA CREO QUE DEBERIA IR EL PSUDOCODIGO, PERO COMO ESTÁ EN EL DESARROLLO NO LO PUSE

Lo que este algoritmo hace es primero ordenar la entrada con el algoritmo sort antes mencionado, esto tiene una complejidad O(n log n). 

Lo que podemos observar es que el resto esta hecho de operaciones que tienen una complejidad de O(1), pero el algoritmo tiene dos ciclos anidados. A simple vista podría decirse que la complejidad de dos ciclos anidados es O($n{^2}$), pero lo que debemos observar es que la variable del segundo ciclo no recorre de 1 a n en cada iteración del primer ciclo, si no que la variable $j$ del ciclo va creciendo y nunca vuelve a ver valores anteriores, por lo tanto a lo largo de las iteraciones del primer ciclo que van de 1 a n, el segundo ciclo también va de  a n sin pasar dos veces por el mismo valor. Por lo tanto en total estos dos ciclos hacen aproximadamente $2*n$ operaciones osea que tienen una complejidad de O(n).

Entonces este algoritmo es dominado por la complejidad del algoritmo sort que es O(n log n), por lo tanto esa es la complejidad del algoritmo. 