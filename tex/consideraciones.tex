\subsection{Lenguaje de implementación}

Para implementar las soluciones algorítmicas desarrolladas en cada problema se utilizó el lenguaje C++, el cual presenta una serie de características muy convenientes. Este lenguaje es imperativo, al igual que el lenguaje de pseudocódigo utilizado para describir las soluciones y probar su correctitud. Adicionalmente, el mismo posee librerías estándar muy completas, versátiles y bien documentadas, lo cual permite abstraer el manejo de memoria, la implementación de estructuras de datos y algoritmos de uso frecuente, y provee mecanismos para realizar mediciones de tiempo de manera fidedigna.

\subsection{Algoritmo de ordenamiento}

En los algoritmos 1 y 2 usamos el algoritmo sort de la stl. Para lograr calcular las complejidades de ambos, necesitamos saber la complejidad de dicho algoritmo.

Buscando en la pagina de http://www.cplusplus.com/reference/algorithm/sort/, encontramos que su complejidad es O(n.log n ) comparaciones. Como con sólo esta informacion no podíamos asegurar que tenga complejidad O(n.log n) operaciones, buscamos que hace el algoritmo sort. Encontramos que para casos chicos hace InsertionSort (ERA ESTE?), y en casos mas grandes IntroSort. IntroSort intenta ordenar usando QuickSort, si no lo resuelve en n.log n pasos, usa HeapSort para garantizar O(n.log n) comparaciones. Viendo el código del algortimo llegamos a que ademas de hacer O(n.log n) comparaciones tambien hace a lo sumo O(n.log n) swaps.

Como en ambos casos donde usamos el algoritmo sort de la stl, nuestros parametros son vector<int> sabemos que la comparaciones y swaps son O(1). Por lo cual podemos garantizar que sort tiene una complejidad O(n log n) operaciones.

Dicho esto pasamos a demostrar que la complejidad del algoritmo utilizado para resolver el problema 1 es O(n log n).

\subsection{Proceso de medición}

